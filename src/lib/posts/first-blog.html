<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* General Body Styling */
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh; /* Full viewport height */
            margin: 0; /* Remove default margin */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f9fafb; /* Light gray background */
            color: #2d3748; /* Dark text color for readability */
            line-height: 1.6; /* Consistent line height */
        }

        /* Container Styling */
        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            max-width: 100%; /* Limit width for larger screens */
            margin: 0 auto; /* Center the container horizontally */
            padding: 2rem; /* Add padding inside the container */
            box-sizing: border-box; /* Ensure padding doesn't affect width */
        }

        /* Header Styling */
        header {
            background-color: #1e3a8a; /* Deep blue header background */
            color: white; /* White text for contrast */
            text-align: center;
            padding: 2rem 0; /* Increased padding for better spacing */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Subtle shadow for depth */
            max-width: 100%;
        }

        header h1 {
            font-size: 2rem; /* Larger font size for emphasis */
            font-weight: bold;
            margin: 0; /* Remove default margin */
            letter-spacing: 1px; /* Slightly spaced-out letters */
        }

        /* Main Content Styling */
        main {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Blog Post Styling */
        .blog-post {
            background-color: white; /* White background for blog posts */
            border-radius: 16px; /* Larger rounded corners for a modern look */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1); /* More pronounced shadow */
            padding: 3rem; /* Increased padding for better spacing */
            margin-bottom: 3rem; /* More space between blog posts */
            transition: transform 0.3s ease, box-shadow 0.3s ease; /* Smooth hover effect */
        }

        .blog-post:hover {
            transform: translateY(-5px); /* Lift the card slightly on hover */
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.15); /* Enhanced shadow on hover */
        }

        .blog-post h2 {
            font-size: 2.25rem; /* Larger heading for better hierarchy */
            margin-bottom: 1.5rem;
            color: #1e3a8a; /* Match header color for consistency */
            font-weight: bold;
        }

        .blog-post p {
            font-size: 1rem;
            line-height: 1.7; /* Slightly increased line height for readability */
            color: #4a5568;
        }

        /* Image Styling */
        .image-container {
            display: flex;
            flex-direction: column;
            align-items: center; /* Center image horizontally */
            justify-content: center; /* Center image vertically if needed */
            margin-top: 2rem; /* Increased spacing above the image */
            text-align: center;
        }

        .blog-image {
            max-width: 100%; /* Make the image responsive */
            height: auto; /* Maintain aspect ratio */
            border-radius: 16px; /* Match rounded corners with blog post */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1); /* Consistent shadow */
            transition: transform 0.3s ease; /* Smooth hover effect */
        }

        .blog-image:hover {
            transform: scale(1.05); /* Slightly zoom in on hover */
        }

        figcaption {
            font-size: 0.9rem;
            color: #4a5568;
            margin-top: 1rem; /* Slightly more space between image and caption */
            font-style: italic;
        }

        /* Code Block Styling */
        .code-container {
            background-color: #f7fafc; /* Light background for code blocks */
            border-radius: 16px; /* Match rounded corners with blog post */
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1); /* Consistent shadow */
            padding: 2rem; /* Padding inside the code block */
            margin-top: 2rem; /* Space above the code block */
            overflow-x: auto; /* Horizontal scrolling for long code lines */
        }

        pre {
            margin: 0; /* Remove default margin */
            font-size: 0.9rem; /* Slightly smaller font size for code */
            line-height: 1.6; /* Consistent line height */
            color: #2d3748; /* Dark text color for readability */
        }

        code {
            display: block; /* Make it behave like a block element */
            white-space: pre-wrap; /* Allow wrapping within the viewport */
            background-color: #f4f4f9; /* Light background for better readability */
            border: 1px solid #ddd; /* Add a subtle border */
            border-radius: 8px; /* Rounded corners */
            padding: 1rem; /* Add some padding */
            font-family: monospace; /* Use a monospace font for code */
            font-size: 0.9rem; /* Adjust font size for readability on mobile */
            overflow-x: auto; /* Enable horizontal scrolling for long lines */
            word-break: break-word; /* Break words if needed for small screens */
        }

        /* Lists Styling */
        ul {
            list-style-type: disc; /* Use bullet points */
            padding-left: 1.5rem; /* Indentation for lists */
            margin-top: 1rem; /* Space above lists */
        }

        li {
            margin-bottom: 0.5rem; /* Space between list items */
            color: #2d3748;
        }

        strong {
            color: #1e3a8a; /* Highlight important text with the header color */
        }

        /* Footer Styling */
        footer {
            background-color: #1e3a8a; /* Deep blue footer background */
            color: white; /* White text for contrast */
            text-align: center;
            padding: 2rem 0; /* Consistent padding */
            margin-top: 2rem; /* Space above the footer */
            box-shadow: 0 -4px 6px rgba(0, 0, 0, 0.1); /* Subtle shadow for depth */
        }

        footer p {
            font-size: 0.9rem;
            margin: 0; /* Remove default margin */
            letter-spacing: 1px; /* Slightly spaced-out letters */
        }

        /* Responsive Design */
        @media (min-width: 768px) {
            .container {
                flex-direction: row; /* Switch to a two-column layout */
                justify-content: space-between; /* Add space between main and aside */
            }

            main {
                flex: 2; /* Main content takes up more space */
            }

            aside {
                flex: 1; /* Sidebar takes up less space */
            }

            code {
                font-size: 0.85rem; /* Slightly smaller font on smaller devices */
                padding: 0.75rem; /* Adjust padding for mobile */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <main>
            <!-- Blog Post -->
            <article class="blog-post">
                <h2>Raft Consensus Algorithm</h2>
                <p>
                    The Raft Consensus Algorithm is a distributed consensus protocol designed to manage a replicated log in a distributed system. It ensures that multiple servers agree on the same sequence of operations, even in the presence of failures. Unlike its predecessor, Paxos, Raft is known for its simplicity and ease of understanding, making it a popular choice for building reliable distributed systems. As its core, Raft divides the consensus problem into three key components: leader election, log replication, and safety. A single leader is elected to manage the log replication process, ensuring that all followers stay in sync. If the leader fails, a new leader is elected through a voting mechanism. This approach simplifies the process of maintaining consistency across nodes in a distributed system.
                </p>

                <!-- Image Figure -->
                <figure class="image-container">
                    <img src="/blog/raft-consensus.png" alt="Visualization of the Raft Consensus Algorithm" class="blog-image">
                    <figcaption>Figure 1: Visualization of the Raft Consensus Algorithm showing leader election.</figcaption>
                </figure>
                <br>
                <p> In this part of the blog post, we'll explore the core concepts of the Raft Consensus Algorithm and how it ensures fault tolerance and consistency in distributed systems. Raft is designed to be simple and understandable, making it an excellent choice for developers and researchers working on distributed systems. </p>
                <p> This blog will break down the Raft algorithm into its three main states: <strong>Follower</strong>, <strong>Candidate</strong>, and <strong>Leader</strong>, and explore how these states interact to ensure a reliable, fault-tolerant system. We'll also examine the election process, leader discovery, and how Raft resolves conflicts. </p>
                <p> Here’s what we’ll cover in this post: </p>
                    <ul>
                    <li><strong>Raft Overview</strong>: A quick introduction to the algorithm and its goals.</li>
                    <li><strong>State 1: Follower</strong>: The starting point for every server in the cluster.</li>
                    <li><strong>State 2: Candidate</strong>: What happens when a Follower times out and initiates an election.</li>
                    <li><strong>State 3: Leader</strong>: The server responsible for maintaining cluster consistency.</li>
                    </ul>
                <p> By the end of this post, you'll have a clear understanding of how Raft works and why it’s one of the most widely adopted consensus algorithms today. Let’s dive in! </p>
                <br><br>
                <h2>Raft Overview</h2>
                <p>
                    Raft is a consensus algorithm designed to manage replicated logs in a distributed system. It was introduced by Diego Ongaro and John Ousterhout in 2014 as an alternative to the more complex Paxos algorithm. Raft is known for its simplicity and understandability, making it an excellent choice for building reliable distributed systems.
                    The primary goal of Raft is to ensure that multiple servers agree on the same sequence of operations, even in the presence of failures. This is achieved by electing a single leader to manage the log replication process. The leader is responsible for coordinating updates and ensuring that all followers stay in sync.
                </p>
                <br><br>
                <h2>Follower</h2>
                <p>
                    The Follower state is the starting point for every server in a Raft cluster. In this state, servers listen for incoming messages from the leader and other followers. If a follower doesn’t receive any messages for a certain period (known as the election timeout), it transitions to the Candidate state and initiates an election.
                </p>
                <br>
                <p>
                    Let's try to implement the node, cluster and initiate the follower in this section with Go implementation.
                </p>
                <ul>
                    <li>
                        <strong>Node</strong>: A single server in the Raft cluster.
                        <pre>
                            <code class="language-go">
// Node represents a single server in the Raft cluster.
type Node struct {
    mu       sync.Mutex
    id       int
    state    string
    term     int
    votes    int
    leaderID int
}
                            </code>
                        </pre>
                    </li>
                    <li>
                        <strong>Cluster</strong>: A group of nodes that communicate with each other.
                        <pre>
                            <code class="language-go">
// Constants
const (
    FOLLOWER  = "Follower"
    CANDIDATE = "Candidate"
    LEADER    = "Leader"
)

// Cluster represents a group of nodes in the Raft cluster.
type Cluster struct {
    nodes []*Node
}
                            </code>
                        </pre>
                    </li>
                    <li>
                        <strong>Initiate Follower</strong>: Start a server in the Follower state.
                        <pre>
                            <code class="language-go">
// NewCluster initializes a new cluster with n nodes
func NewCluster(n int) *Cluster {
    cluster := &Cluster{}
    for i := 0; i < n; i++ {
        node := &Node{
            id:       i,
            state:    FOLLOWER,
            term:     0,
            votes:    0,
            leaderID: -1,
        }
        cluster.nodes = append(cluster.nodes, node)
    }
    return cluster
}
                            </code>
                        </pre>
                    </li>
                </ul>

                <h2>Candidate</h2>
                <p>
                    The Candidate state is entered when a follower times out and initiates an election. In this state, the server transitions from follower to candidate and requests votes from other servers in the cluster. If a candidate receives votes from a majority of servers, it becomes the new leader. Otherwise, the election fails, and the candidate reverts to the follower state.
                </p>
                <br>
                <p>
                    In this part of implementation, we'll explore how the candidate will request votes from other servers and become the leader.
                </p>
                <ul>
                    <li>
                        <strong>Start Election</strong>: A follower transitions to the candidate state and starts an election. If the candidate receives votes from a majority of servers, it becomes the leader.
                        <pre>
                            <code class="language-go">
// StartElection attempts to elect a leader
func (n *Node) StartElection(cluster *Cluster) {
    n.mu.Lock()
    n.state = CANDIDATE
    n.term++
    n.votes = 1
    n.mu.Unlock()

    fmt.Printf("Node %d starts election for Term %d\n", n.id, n.term)

    // Request votes from other nodes
    votes := 1
    for _, peer := range cluster.nodes {
        if peer.id != n.id && peer.RequestVote(n.term) {
            votes++
        }
    }

    // Check if election was successful
    if votes > len(cluster.nodes)/2 {
        n.mu.Lock()
        n.state = LEADER
        n.leaderID = n.id
        n.mu.Unlock()
        fmt.Printf("Node %d is elected as leader for term %d\n", n.id, n.term)
        go n.SendHeartbeats(cluster)
    }
}
                            </code>
                        </pre>
                    </li>
                    <li>
                        <strong>Request Votes</strong>: A candidate requests votes from other servers in the cluster.
                        <pre>
                            <code class="language-go">
// RequestVote handles a vote request
func (n *Node) RequestVote(term int) bool {
    n.mu.Lock()
    defer n.mu.Unlock()

    if term > n.term {
        n.term = term
        n.state = FOLLOWER
        fmt.Printf("Node %d voted for term %d\n", n.id, term)
        return true
    }

    return false
}
                            </code>
                        </pre>
                    </li>
                </ul>
                <br><br>
                <h2>Leader</h2>
                <p>
                    The Leader state is responsible for maintaining cluster consistency by coordinating updates and ensuring that all followers stay in sync. The leader sends heartbeat messages to followers to let them know it's still active. If a follower doesn't receive a heartbeat within a certain period, it transitions back to the candidate state and starts a new election.
                </p>
                <br><br>
                <p>
                    In this section, we'll explore how the leader sends heartbeat messages to followers and maintains cluster consistency.
                </p>
                <ul>
                    <li>
                        <strong>Send Heartbeats</strong>: The leader sends heartbeat messages to followers to maintain cluster consistency.
                        <pre>
                            <code class="language-go">
// SendHeartbeats simulates leader sending heartbeats
func (n *Node) SendHeartbeats(cluster *Cluster) {
    for {
        if n.state != LEADER {
            return
        }

        fmt.Printf("Leader %d sending heartbeats...\n", n.id)
        for _, peer := range cluster.nodes {
            if peer.id != n.id {
                peer.ReceiveHeartbeat(n.id)
            }
        }
        time.Sleep(2 * time.Second)
    }
}
                            </code>
                        </pre>
                    </li>
                    <li>
                        <strong>Follower Receiving Heartbeats</strong>: A follower receives heartbeats from the leader to stay in sync.
                        <pre>
                            <code class="language-go">
// ReceiveHeartbeat resets election timeout
func (n *Node) ReceiveHeartbeat(leaderID int) {
    n.mu.Lock()
    n.state = FOLLOWER
    n.leaderID = leaderID
    n.mu.Unlock()
    fmt.Printf("Node %d received heartbeat from leader %d\n", n.id, leaderID)
}
                            </code>
                        </pre>
                    </li>
                </ul>
            
                <h2>Cluster Simulation</h2>
                <p>
                    Now that we've implemented the core components of the Raft algorithm, let's simulate a Raft cluster with multiple nodes and observe how they interact. We'll start by creating a new cluster with three nodes and initiating an election to elect a leader. We'll then simulate the leader sending heartbeats to followers to maintain cluster consistency.
                </p>
                <pre>
                    <code class="language-go">
// Simulate runs the Raft protocol
func (c *Cluster) Simulate() {
    for _, node := range c.nodes {
        go func(n *Node) {
            for {
                time.Sleep(time.Duration(rand.Intn(5)+3) * time.Second)
                if n.state == FOLLOWER {
                    n.StartElection(c)
                }
            }
        }(node)
    }
}

func main() {
    rand.Seed(time.Now().UnixNano())

    // Initialize a cluster with 5 nodes
    cluster := NewCluster(5)
    cluster.Simulate()

    time.Sleep(20 * time.Second) // Allow time for elections
}
                    </code>
                </pre>
                <figure class="image-container">
                    <img src="/blog/raft-simulation.png" alt="Raft Cluster Simulation" class="blog-image">
                    <figcaption>Figure 2: Visualization of a Raft cluster simulation with multiple nodes.</figcaption>
                </figure>
                <br>
                <p>
                    In the visualization above, we can see a Node 4 starts election for Term 19 and is elected as the leader for the term. The leader sends
                    heartbeats to other nodes to maintain cluster consistency. This simulation demonstrates how Raft ensures fault tolerance and consistency in a distributed system.
                </p>

                <h2>Conclusion</h2>
                <p>
                    The Raft Consensus Algorithm is a powerful tool for building reliable distributed systems. By dividing the consensus problem into leader election, log replication, and safety, Raft simplifies the process of maintaining consistency across nodes in a distributed system. Its clear and understandable design makes it an excellent choice for developers and researchers working on distributed systems. In this blog post, we explored the core concepts of the Raft algorithm, including the Follower, Candidate, and Leader states, and how they interact to ensure fault tolerance and consistency. We implemented a basic version of Raft in Go to simulate a Raft cluster with multiple nodes and observed how they elect a leader and maintain cluster consistency.
                </p>

                <h2>References:</h2>
                <ul>
                    <li><a href="https://raft.github.io/">Raft Consensus Algorithm</a></li>
                    <li><a href="https://raft.github.io/raft.pdf">The Raft Consensus Algorithm (PDF)</a></li>
                    <li><a href="https://github.com/HarryChang30/go-raft-consensus">Full Source Code Implementation</a></li>
                </ul>
            </article>

            <!-- Another Blog Post -->
        </main>

        <!-- Sidebar (Optional) -->
        <!-- <aside>
            <div class="bg-white shadow-md rounded-lg p-4">
                <h3 class="text-lg font-semibold text-gray-800">Categories</h3>
                <ul class="mt-2">
                    <li><a href="#" class="text-blue-500 hover:text-blue-700">Web Development</a></li>
                    <li><a href="#" class="text-blue-500 hover:text-blue-700">Data Science</a></li>
                    <li><a href="#" class="text-blue-500 hover:text-blue-700">Artificial Intelligence</a></li>
                </ul>
            </div>
        </aside> -->
    </div>
</body>
</html>